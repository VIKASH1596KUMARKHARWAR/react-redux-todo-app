{"ast":null,"code":"// import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\n// import { nanoid } from 'nanoid';\n// export const getTodosAsync = createAsyncThunk(\n// \t'todos/getTodosAsync',\n// \tasync () => {\n// \t\tconst resp = await fetch('http://localhost:7000/todos');\n// \t\tif (resp.ok) {\n// \t\t\tconst todos = await resp.json();\n// \t\t\treturn { todos };\n// \t\t}\n// \t}\n// );\n// export const addTodoAsync = createAsyncThunk(\n// \t'todos/addTodoAsync',\n// \tasync (payload) => {\n// \t\tconst resp = await fetch('http://localhost:7000/todos', {\n// \t\t\tmethod: 'POST',\n// \t\t\theaders: {\n// \t\t\t\t'Content-Type': 'application/json',\n// \t\t\t},\n// \t\t\tbody: JSON.stringify({ title: payload.title, dueDate: payload.dueDate }),\n// \t\t});\n// \t\tif (resp.ok) {\n// \t\t\tconst todo = await resp.json();\n// \t\t\treturn { todo };\n// \t\t}\n// \t}\n// );\n// export const toggleCompleteAsync = createAsyncThunk(\n// \t'todos/completeTodoAsync',\n// \tasync (payload) => {\n// \t\tconst resp = await fetch(`http://localhost:7000/todos/${payload.id}`, {\n// \t\t\tmethod: 'PATCH',\n// \t\t\theaders: {\n// \t\t\t\t'Content-Type': 'application/json',\n// \t\t\t},\n// \t\t\tbody: JSON.stringify({ completed: payload.completed }),\n// \t\t});\n// \t\tif (resp.ok) {\n// \t\t\tconst todo = await resp.json();\n// \t\t\treturn { todo };\n// \t\t}\n// \t}\n// );\n// export const deleteTodoAsync = createAsyncThunk(\n// \t'todos/deleteTodoAsync',\n// \tasync (payload) => {\n// \t\tconst resp = await fetch(`http://localhost:7000/todos/${payload.id}`, {\n// \t\t\tmethod: 'DELETE',\n// \t\t});\n// \t\tif (resp.ok) {\n// \t\t\treturn { id: payload.id };\n// \t\t}\n// \t}\n// );\n// export const todoSlice = createSlice({\n// \tname: 'todos',\n// \tinitialState: [],\n// \treducers: {\n// \t\taddTodo: (state, action) => {\n// \t\t\tconst todo = {\n// \t\t\t\tid: nanoid(),\n// \t\t\t\ttitle: action.payload.title,\n// \t\t\t\tdueDate: action.payload.dueDate,\n// \t\t\t\tcompleted: false,\n// \t\t\t};\n// \t\t\tstate.push(todo);\n// \t\t},\n// \t\ttoggleComplete: (state, action) => {\n// \t\t\tconst index = state.findIndex((todo) => todo.id === action.payload.id);\n// \t\t\tstate[index].completed = action.payload.completed;\n// \t\t},\n// \t\tdeleteTodo: (state, action) => {\n// \t\t\treturn state.filter((todo) => todo.id !== action.payload.id);\n// \t\t},\n// \t},\n// \textraReducers: {\n// \t\t[getTodosAsync.fulfilled]: (state, action) => {\n// \t\t\treturn action.payload.todos;\n// \t\t},\n// \t\t[addTodoAsync.fulfilled]: (state, action) => {\n// \t\t\tstate.push(action.payload.todo);\n// \t\t},\n// \t\t[toggleCompleteAsync.fulfilled]: (state, action) => {\n// \t\t\tconst index = state.findIndex(\n// \t\t\t\t(todo) => todo.id === action.payload.todo.id\n// \t\t\t);\n// \t\t\tstate[index].completed = action.payload.todo.completed;\n// \t\t},\n// \t\t[deleteTodoAsync.fulfilled]: (state, action) => {\n// \t\t\treturn state.filter((todo) => todo.id !== action.payload.id);\n// \t\t},\n// \t},\n// });\n// export const { addTodo, toggleComplete, deleteTodo } = todoSlice.actions;\n// export default todoSlice.reducer;\nimport{createSlice,createAsyncThunk}from'@reduxjs/toolkit';// Async actions for CRUD operations\nexport const getTodosAsync=createAsyncThunk('todos/getTodosAsync',async()=>{const response=await fetch('http://localhost:7000/todos');if(response.ok){const todos=await response.json();return{todos};}});export const addTodoAsync=createAsyncThunk('todos/addTodoAsync',async payload=>{const response=await fetch('http://localhost:7000/todos',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});if(response.ok){const todo=await response.json();return{todo};}});export const toggleCompleteAsync=createAsyncThunk('todos/toggleCompleteAsync',async payload=>{const response=await fetch(`http://localhost:7000/todos/${payload.id}`,{method:'PATCH',headers:{'Content-Type':'application/json'},body:JSON.stringify({completed:payload.completed})});if(response.ok){const todo=await response.json();return{todo};}});export const deleteTodoAsync=createAsyncThunk('todos/deleteTodoAsync',async payload=>{const response=await fetch(`http://localhost:7000/todos/${payload.id}`,{method:'DELETE'});if(response.ok){return{id:payload.id};}});// Slice definition\nconst todoSlice=createSlice({name:'todos',initialState:{items:[],filter:'all'// Filters: 'all', 'completed', 'pending', 'overdue'\n},reducers:{setFilter:(state,action)=>{state.filter=action.payload;}},extraReducers:{[getTodosAsync.fulfilled]:(state,action)=>{state.items=action.payload.todos;},[addTodoAsync.fulfilled]:(state,action)=>{state.items.push(action.payload.todo);},[toggleCompleteAsync.fulfilled]:(state,action)=>{const index=state.items.findIndex(todo=>todo.id===action.payload.todo.id);state.items[index].completed=action.payload.todo.completed;},[deleteTodoAsync.fulfilled]:(state,action)=>{state.items=state.items.filter(todo=>todo.id!==action.payload.id);}}});export const{setFilter}=todoSlice.actions;export default todoSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","getTodosAsync","response","fetch","ok","todos","json","addTodoAsync","payload","method","headers","body","JSON","stringify","todo","toggleCompleteAsync","id","completed","deleteTodoAsync","todoSlice","name","initialState","items","filter","reducers","setFilter","state","action","extraReducers","fulfilled","push","index","findIndex","actions","reducer"],"sources":["/home/vikash/Documents/react-redux-todo-app/final/src/redux/todoSlice.js"],"sourcesContent":["// import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\n// import { nanoid } from 'nanoid';\n\n// export const getTodosAsync = createAsyncThunk(\n// \t'todos/getTodosAsync',\n// \tasync () => {\n// \t\tconst resp = await fetch('http://localhost:7000/todos');\n// \t\tif (resp.ok) {\n// \t\t\tconst todos = await resp.json();\n// \t\t\treturn { todos };\n// \t\t}\n// \t}\n// );\n\n// export const addTodoAsync = createAsyncThunk(\n// \t'todos/addTodoAsync',\n// \tasync (payload) => {\n// \t\tconst resp = await fetch('http://localhost:7000/todos', {\n// \t\t\tmethod: 'POST',\n// \t\t\theaders: {\n// \t\t\t\t'Content-Type': 'application/json',\n// \t\t\t},\n// \t\t\tbody: JSON.stringify({ title: payload.title, dueDate: payload.dueDate }),\n// \t\t});\n\n// \t\tif (resp.ok) {\n// \t\t\tconst todo = await resp.json();\n// \t\t\treturn { todo };\n// \t\t}\n// \t}\n// );\n\n// export const toggleCompleteAsync = createAsyncThunk(\n// \t'todos/completeTodoAsync',\n// \tasync (payload) => {\n// \t\tconst resp = await fetch(`http://localhost:7000/todos/${payload.id}`, {\n// \t\t\tmethod: 'PATCH',\n// \t\t\theaders: {\n// \t\t\t\t'Content-Type': 'application/json',\n// \t\t\t},\n// \t\t\tbody: JSON.stringify({ completed: payload.completed }),\n// \t\t});\n\n// \t\tif (resp.ok) {\n// \t\t\tconst todo = await resp.json();\n// \t\t\treturn { todo };\n// \t\t}\n// \t}\n// );\n\n// export const deleteTodoAsync = createAsyncThunk(\n// \t'todos/deleteTodoAsync',\n// \tasync (payload) => {\n// \t\tconst resp = await fetch(`http://localhost:7000/todos/${payload.id}`, {\n// \t\t\tmethod: 'DELETE',\n// \t\t});\n\n// \t\tif (resp.ok) {\n// \t\t\treturn { id: payload.id };\n// \t\t}\n// \t}\n// );\n\n// export const todoSlice = createSlice({\n// \tname: 'todos',\n// \tinitialState: [],\n// \treducers: {\n// \t\taddTodo: (state, action) => {\n// \t\t\tconst todo = {\n// \t\t\t\tid: nanoid(),\n// \t\t\t\ttitle: action.payload.title,\n// \t\t\t\tdueDate: action.payload.dueDate,\n// \t\t\t\tcompleted: false,\n// \t\t\t};\n// \t\t\tstate.push(todo);\n// \t\t},\n// \t\ttoggleComplete: (state, action) => {\n// \t\t\tconst index = state.findIndex((todo) => todo.id === action.payload.id);\n// \t\t\tstate[index].completed = action.payload.completed;\n// \t\t},\n// \t\tdeleteTodo: (state, action) => {\n// \t\t\treturn state.filter((todo) => todo.id !== action.payload.id);\n// \t\t},\n// \t},\n// \textraReducers: {\n// \t\t[getTodosAsync.fulfilled]: (state, action) => {\n// \t\t\treturn action.payload.todos;\n// \t\t},\n// \t\t[addTodoAsync.fulfilled]: (state, action) => {\n// \t\t\tstate.push(action.payload.todo);\n// \t\t},\n// \t\t[toggleCompleteAsync.fulfilled]: (state, action) => {\n// \t\t\tconst index = state.findIndex(\n// \t\t\t\t(todo) => todo.id === action.payload.todo.id\n// \t\t\t);\n// \t\t\tstate[index].completed = action.payload.todo.completed;\n// \t\t},\n// \t\t[deleteTodoAsync.fulfilled]: (state, action) => {\n// \t\t\treturn state.filter((todo) => todo.id !== action.payload.id);\n// \t\t},\n// \t},\n// });\n\n// export const { addTodo, toggleComplete, deleteTodo } = todoSlice.actions;\n\n// export default todoSlice.reducer;\n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// Async actions for CRUD operations\nexport const getTodosAsync = createAsyncThunk('todos/getTodosAsync', async () => {\n\tconst response = await fetch('http://localhost:7000/todos');\n\tif (response.ok) {\n\t\tconst todos = await response.json();\n\t\treturn { todos };\n\t}\n});\n\nexport const addTodoAsync = createAsyncThunk('todos/addTodoAsync', async (payload) => {\n\tconst response = await fetch('http://localhost:7000/todos', {\n\t\tmethod: 'POST',\n\t\theaders: { 'Content-Type': 'application/json' },\n\t\tbody: JSON.stringify(payload),\n\t});\n\tif (response.ok) {\n\t\tconst todo = await response.json();\n\t\treturn { todo };\n\t}\n});\n\nexport const toggleCompleteAsync = createAsyncThunk('todos/toggleCompleteAsync', async (payload) => {\n\tconst response = await fetch(`http://localhost:7000/todos/${payload.id}`, {\n\t\tmethod: 'PATCH',\n\t\theaders: { 'Content-Type': 'application/json' },\n\t\tbody: JSON.stringify({ completed: payload.completed }),\n\t});\n\tif (response.ok) {\n\t\tconst todo = await response.json();\n\t\treturn { todo };\n\t}\n});\n\nexport const deleteTodoAsync = createAsyncThunk('todos/deleteTodoAsync', async (payload) => {\n\tconst response = await fetch(`http://localhost:7000/todos/${payload.id}`, {\n\t\tmethod: 'DELETE',\n\t});\n\tif (response.ok) {\n\t\treturn { id: payload.id };\n\t}\n});\n\n// Slice definition\nconst todoSlice = createSlice({\n\tname: 'todos',\n\tinitialState: {\n\t\titems: [],\n\t\tfilter: 'all', // Filters: 'all', 'completed', 'pending', 'overdue'\n\t},\n\treducers: {\n\t\tsetFilter: (state, action) => {\n\t\t\tstate.filter = action.payload;\n\t\t},\n\t},\n\textraReducers: {\n\t\t[getTodosAsync.fulfilled]: (state, action) => {\n\t\t\tstate.items = action.payload.todos;\n\t\t},\n\t\t[addTodoAsync.fulfilled]: (state, action) => {\n\t\t\tstate.items.push(action.payload.todo);\n\t\t},\n\t\t[toggleCompleteAsync.fulfilled]: (state, action) => {\n\t\t\tconst index = state.items.findIndex((todo) => todo.id === action.payload.todo.id);\n\t\t\tstate.items[index].completed = action.payload.todo.completed;\n\t\t},\n\t\t[deleteTodoAsync.fulfilled]: (state, action) => {\n\t\t\tstate.items = state.items.filter((todo) => todo.id !== action.payload.id);\n\t\t},\n\t},\n});\n\nexport const { setFilter } = todoSlice.actions;\nexport default todoSlice.reducer;\n"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA,OAASA,WAAW,CAAEC,gBAAgB,KAAQ,kBAAkB,CAEhE;AACA,MAAO,MAAM,CAAAC,aAAa,CAAGD,gBAAgB,CAAC,qBAAqB,CAAE,SAAY,CAChF,KAAM,CAAAE,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,6BAA6B,CAAC,CAC3D,GAAID,QAAQ,CAACE,EAAE,CAAE,CAChB,KAAM,CAAAC,KAAK,CAAG,KAAM,CAAAH,QAAQ,CAACI,IAAI,CAAC,CAAC,CACnC,MAAO,CAAED,KAAM,CAAC,CACjB,CACD,CAAC,CAAC,CAEF,MAAO,MAAM,CAAAE,YAAY,CAAGP,gBAAgB,CAAC,oBAAoB,CAAE,KAAO,CAAAQ,OAAO,EAAK,CACrF,KAAM,CAAAN,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,6BAA6B,CAAE,CAC3DM,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CAAE,cAAc,CAAE,kBAAmB,CAAC,CAC/CC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACL,OAAO,CAC7B,CAAC,CAAC,CACF,GAAIN,QAAQ,CAACE,EAAE,CAAE,CAChB,KAAM,CAAAU,IAAI,CAAG,KAAM,CAAAZ,QAAQ,CAACI,IAAI,CAAC,CAAC,CAClC,MAAO,CAAEQ,IAAK,CAAC,CAChB,CACD,CAAC,CAAC,CAEF,MAAO,MAAM,CAAAC,mBAAmB,CAAGf,gBAAgB,CAAC,2BAA2B,CAAE,KAAO,CAAAQ,OAAO,EAAK,CACnG,KAAM,CAAAN,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,+BAA+BK,OAAO,CAACQ,EAAE,EAAE,CAAE,CACzEP,MAAM,CAAE,OAAO,CACfC,OAAO,CAAE,CAAE,cAAc,CAAE,kBAAmB,CAAC,CAC/CC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAAC,CAAEI,SAAS,CAAET,OAAO,CAACS,SAAU,CAAC,CACtD,CAAC,CAAC,CACF,GAAIf,QAAQ,CAACE,EAAE,CAAE,CAChB,KAAM,CAAAU,IAAI,CAAG,KAAM,CAAAZ,QAAQ,CAACI,IAAI,CAAC,CAAC,CAClC,MAAO,CAAEQ,IAAK,CAAC,CAChB,CACD,CAAC,CAAC,CAEF,MAAO,MAAM,CAAAI,eAAe,CAAGlB,gBAAgB,CAAC,uBAAuB,CAAE,KAAO,CAAAQ,OAAO,EAAK,CAC3F,KAAM,CAAAN,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,+BAA+BK,OAAO,CAACQ,EAAE,EAAE,CAAE,CACzEP,MAAM,CAAE,QACT,CAAC,CAAC,CACF,GAAIP,QAAQ,CAACE,EAAE,CAAE,CAChB,MAAO,CAAEY,EAAE,CAAER,OAAO,CAACQ,EAAG,CAAC,CAC1B,CACD,CAAC,CAAC,CAEF;AACA,KAAM,CAAAG,SAAS,CAAGpB,WAAW,CAAC,CAC7BqB,IAAI,CAAE,OAAO,CACbC,YAAY,CAAE,CACbC,KAAK,CAAE,EAAE,CACTC,MAAM,CAAE,KAAO;AAChB,CAAC,CACDC,QAAQ,CAAE,CACTC,SAAS,CAAEA,CAACC,KAAK,CAAEC,MAAM,GAAK,CAC7BD,KAAK,CAACH,MAAM,CAAGI,MAAM,CAACnB,OAAO,CAC9B,CACD,CAAC,CACDoB,aAAa,CAAE,CACd,CAAC3B,aAAa,CAAC4B,SAAS,EAAG,CAACH,KAAK,CAAEC,MAAM,GAAK,CAC7CD,KAAK,CAACJ,KAAK,CAAGK,MAAM,CAACnB,OAAO,CAACH,KAAK,CACnC,CAAC,CACD,CAACE,YAAY,CAACsB,SAAS,EAAG,CAACH,KAAK,CAAEC,MAAM,GAAK,CAC5CD,KAAK,CAACJ,KAAK,CAACQ,IAAI,CAACH,MAAM,CAACnB,OAAO,CAACM,IAAI,CAAC,CACtC,CAAC,CACD,CAACC,mBAAmB,CAACc,SAAS,EAAG,CAACH,KAAK,CAAEC,MAAM,GAAK,CACnD,KAAM,CAAAI,KAAK,CAAGL,KAAK,CAACJ,KAAK,CAACU,SAAS,CAAElB,IAAI,EAAKA,IAAI,CAACE,EAAE,GAAKW,MAAM,CAACnB,OAAO,CAACM,IAAI,CAACE,EAAE,CAAC,CACjFU,KAAK,CAACJ,KAAK,CAACS,KAAK,CAAC,CAACd,SAAS,CAAGU,MAAM,CAACnB,OAAO,CAACM,IAAI,CAACG,SAAS,CAC7D,CAAC,CACD,CAACC,eAAe,CAACW,SAAS,EAAG,CAACH,KAAK,CAAEC,MAAM,GAAK,CAC/CD,KAAK,CAACJ,KAAK,CAAGI,KAAK,CAACJ,KAAK,CAACC,MAAM,CAAET,IAAI,EAAKA,IAAI,CAACE,EAAE,GAAKW,MAAM,CAACnB,OAAO,CAACQ,EAAE,CAAC,CAC1E,CACD,CACD,CAAC,CAAC,CAEF,MAAO,MAAM,CAAES,SAAU,CAAC,CAAGN,SAAS,CAACc,OAAO,CAC9C,cAAe,CAAAd,SAAS,CAACe,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}